{"ast":null,"code":"import * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport class Pointer extends Base {\n  constructor(offsetType, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') {\n      this.type = null;\n    }\n    if (this.options.type == null) {\n      this.options.type = 'local';\n    }\n    if (this.options.allowNull == null) {\n      this.options.allowNull = true;\n    }\n    if (this.options.nullValue == null) {\n      this.options.nullValue = 0;\n    }\n    if (this.options.lazy == null) {\n      this.options.lazy = false;\n    }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if (offset === this.options.nullValue && this.options.allowNull) {\n      return null;\n    }\n    let relative;\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx._startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos - this.offsetType.size();\n        break;\n      case 'parent':\n        relative = ctx.parent._startOffset;\n        break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n        relative = c._startOffset || 0;\n    }\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n    const ptr = offset + relative;\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) {\n          return val;\n        }\n        const {\n          pos\n        } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue\n        });\n      }\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local':\n      case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default:\n        // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n    let {\n      type\n    } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n    return this.offsetType.size();\n  }\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if (val == null) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default:\n        // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n    let {\n      type\n    } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}","map":{"version":3,"names":["utils","Base","Pointer","constructor","offsetType","type","options","arguments","length","undefined","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","decode","stream","ctx","offset","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"sources":["/Users/tomertal/Development/code/portfolio-site/node_modules/restructure/src/Pointer.js"],"sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}